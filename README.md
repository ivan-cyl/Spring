当我们完成某项需求时，可以通过在接口添加相关功能来完成相关需求的添加，但这样会造成一定的问题，如果现在修改了需求怎么办呢，「我们可以使用全局替换」，的确使用全局变量可以完成相关操作，但是如果经常更换需求此解决方法就有了一定的问题。

可以看出在上述例子中，代码耦合度过高，而我们需要在不同条件下创建不同实例，此时我们可以使用「工厂模式」来降低耦合度。「工厂模式」常用来解决接口选择的问题，「工厂模式」优点：调用者想创建一个对象，只要知道其名称就可以了创建了；扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以；可以屏蔽产品的具体实现，调用者只关心产品的接口。

但是「工厂模式」也有着一定的缺陷，每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。看来「工厂模式」也有着不足，有什么方法可以解决相关问题呢？

**Spring！！**

**将对象交给外部去创建的机制，不仅仅是工厂模式，它还被称为控制反转（Inverse of Control），它还有另一个更常用的名称，依赖注入（Dependency Injection）。这种机制，业界已经有很成熟的实现了，它就是Spring Framework**



**为什么要使用依赖注入**

- 传统的代码，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时，需要修改多处地方。同时，过度耦合也使得对象难以进行单元测试。

- 依赖注入把对象的创造交给外部去管理,很好的解决了代码**紧耦合**（tight couple）的问题，是一种让代码实现**松耦合**（loose couple）的机制。

- 松耦合让代码更具灵活性，能更好地**应对需求变动**，以及**方便单元测试**。

  

**为什么要使用Spring**

- 使用Spring框架主要是为了**简化Java开发**（大多数框架都是为了简化开发），它帮我们封装好了很多完善的功能，而且Spring的生态圈也非常庞大。

- 基于XML的配置是Spring提供的**最原始的依赖注入配置方式**，从Spring诞生之时就有了，功能也是最完善的（但是貌似有更好的配置方法，明天看看！）。

  

**Constructor注入 vs Setter注入**

- Constructor注入能够强制要求调用者注入构造函数中的所有参数，否则在容器初始化时就会失败；但是如果要注入的对象过多，就会导致**构造函数过于庞大**。

- Setter注入，类似于Builder模式，将原本庞大的构造函数，拆解为了**一个小的构造函数**和**许多个set方法**。setter注入不能保证对象一定会被注入，但是可以使用**@Required**注解，强制要求使用者注入对象，否则在容器初始化时就会报错。

  

使用Java Config，只需要创建一个配置类，在配置类中编写方法，返回要注入的对象，并给方法加上@Bean注解，告诉Spring为返回的对象创建实例

| **特点\配置方式**            | XML                                                | 注解                                   | Java Config                                         |
| ---------------------------- | -------------------------------------------------- | -------------------------------------- | --------------------------------------------------- |
| 类型是否安全                 | N                                                  | Y                                      | Y                                                   |
| 查找实现类是否方便           | N，需要查找所有xml                                 | Y，只需看哪个实现类上有加注解          | N，需要查找所有Java Config                          |
| 可读性                       | 差，有很多xml标签，不易阅读                        | 很好，注解的同时起到注释的作用         | 较好，对于Java程序员来说，阅读Java代码比阅读xml方便 |
| 配置简洁性                   | 很啰嗦                                             | 十分简洁                               | 有点啰嗦                                            |
| 修改配置是否需要重新编译     | N，直接替换xml文件即可                             | Y，需重新编译出class文件，然后进行替换 | Y，同注解配置                                       |
| 是否会侵入代码               | N                                                  | Y                                      | N                                                   |
| 自由度                       | 低，可以使用SPEL语法，但是SPEL语法能实现的功能有限 | 低，只能基于注解的属性进行配置         | 高，可以自由使用Java语法，调用各种函数来注入对象    |
| 是否可以注入不是自己维护的类 | Y                                                  | N                                      | Y                                                   |

 

- xml配置相对于其他两种方式来说，几乎没什么优势，唯一的优势就是**修改后不需要重新编译**，因此**对于一些经常切换实现类的对象，可以采用xml的方式进行配置**。还有就是由于xml是Spring一开始就提供的配置方式，因此很多旧代码还是采用xml，所以在维护旧代码时会免不了用到xml。
- **注解用起来非常地简洁，代码量十分少，因此是项目的第一选择**。只有当需要注入代码不是自己维护的第三方jar包中的类时，或者需要更为灵活地注入，比如说需要调用某个接口，查询数据，然后把这个数据赋值给要注入的对象，那么这时候就需要用到Java Config。


以上内容整理于网络，如有侵权请联系删除:ivan.cyl@outlook.com

The above content is sorted out on the network. If there is infringement, please contact to delete :ivan.cyl@outlook.com
